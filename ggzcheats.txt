
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = " ggzcheats --- https://discord.gg/S63mWAfHJr ",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "laoding script...",
   LoadingSubtitle = "by team ggz",
   Theme = "Bloom", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = true, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "S63mWAfHJr", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

Rayfield:Notify({
   Title = "Script injected succesfully",
   Content = "Dc for support",
   Duration = 4.5,
   Image = nil,
})

local CredTab = Window:CreateTab("Credits and Support", nil) -- Title, Image
local CredSection = CredTab:CreateSection("Credtis")

local Paragraph = CredTab:CreateParagraph({Title = "I just wanna give a special thanks to these pepole for making this possible!!", Content = "                                                                                                                                                                                                                                                          Owner: zeynqq.                                                                                                      Owner2: ggzcheats                                                                                                                                                                                                            Staff: alice                                                                                                                                                                   Scripter:ZeroErrorDev                                                                                                                                                                    Tester + Scripter: er00rr"})

local CredSection = CredTab:CreateSection("Support")

local Paragraph = CredTab:CreateParagraph({Title = "Support Section", Content = "Reach out to the discord for help about anything! I will also mention other support places                                                                                                                                                                                                                                                                                                            Github support: https://github.com/zeynqq/ggzcheat"})

local VisTab = Window:CreateTab("Visuals", nil) -- Title, Image
local VisSection = VisTab:CreateSection("WallHacks")

-- Settings
local Settings = {
    Box_Color = Color3.fromRGB(255, 0, 0),
    Box_Thickness = 2,
    Team_Check = false,
    Team_Color = false,
    Autothickness = true
}

-- Toggle
local ToggleState = false

local Toggle = VisTab:CreateToggle({
    Name = "Toggle ESP",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        ToggleState = Value
    end,
})

-- Locals
local Space = game:GetService("Workspace")
local Player = game:GetService("Players").LocalPlayer
local Camera = Space.CurrentCamera

local function NewLine(color, thickness)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function Vis(lib, state)
    for _, v in pairs(lib) do
        v.Visible = state
    end
end

local function Colorize(lib, color)
    for _, v in pairs(lib) do
        v.Color = color
    end
end

local function Main(plr)
    repeat wait() until plr.Character and plr.Character:FindFirstChild("Humanoid")
    
    local Library = {
        TL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness)
    }
    
    local oripart = Instance.new("Part")
    oripart.Parent = Space
    oripart.Transparency = 1
    oripart.CanCollide = false
    oripart.Size = Vector3.new(1, 1, 1)
    oripart.Position = Vector3.new(0, 0, 0)
    
    local function Updater()
        local c
        c = game:GetService("RunService").RenderStepped:Connect(function()
            if not ToggleState then
                Vis(Library, false)
                return
            end
            
            if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Head") and plr.Character.Humanoid.Health > 0 then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)
                if vis then
                    oripart.Size = Vector3.new(Hum.HumanoidRootPart.Size.X, Hum.HumanoidRootPart.Size.Y*1.5, Hum.HumanoidRootPart.Size.Z)
                    oripart.CFrame = CFrame.new(Hum.HumanoidRootPart.CFrame.Position, Camera.CFrame.Position)
                    local SizeX = oripart.Size.X
                    local SizeY = oripart.Size.Y
                    local TL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, SizeY, 0)).p)
                    local TR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, SizeY, 0)).p)
                    local BL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, -SizeY, 0)).p)
                    local BR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, -SizeY, 0)).p)
                    
                    Library.TL1.From = Vector2.new(TL.X, TL.Y)
                    Library.TL1.To = Vector2.new(TL.X + 5, TL.Y)
                    Library.TL2.From = Vector2.new(TL.X, TL.Y)
                    Library.TL2.To = Vector2.new(TL.X, TL.Y + 5)
                    Library.TR1.From = Vector2.new(TR.X, TR.Y)
                    Library.TR1.To = Vector2.new(TR.X - 5, TR.Y)
                    Library.TR2.From = Vector2.new(TR.X, TR.Y)
                    Library.TR2.To = Vector2.new(TR.X, TR.Y + 5)
                    Library.BL1.From = Vector2.new(BL.X, BL.Y)
                    Library.BL1.To = Vector2.new(BL.X + 5, BL.Y)
                    Library.BL2.From = Vector2.new(BL.X, BL.Y)
                    Library.BL2.To = Vector2.new(BL.X, BL.Y - 5)
                    Library.BR1.From = Vector2.new(BR.X, BR.Y)
                    Library.BR1.To = Vector2.new(BR.X - 5, BR.Y)
                    Library.BR2.From = Vector2.new(BR.X, BR.Y)
                    Library.BR2.To = Vector2.new(BR.X, BR.Y - 5)
                    
                    Vis(Library, true)
                else
                    Vis(Library, false)
                end
            else
                Vis(Library, false)
            end
        end)
    end
    
    coroutine.wrap(Updater)()
end

for _, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= Player.Name then
        coroutine.wrap(Main)(v)
    end
end

game:GetService("Players").PlayerAdded:Connect(function(newplr)
    coroutine.wrap(Main)(newplr)
end)


local Button = VisTab:CreateButton({
   Name = "Tracers",
   Callback = function()
        -- Locals
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = game:GetService("Workspace").CurrentCamera
local RunService = game:GetService("RunService")

-- Function to create new line
local function NewLine()
    local line = Drawing.new("Line")
    line.Visible = true
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = Color3.fromRGB(255, 0, 0) -- Red color
    line.Thickness = 2
    line.Transparency = 1
    return line
end

-- Table to store lines
local Lines = {}

-- Function to update lines
local function UpdateLines()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude
            if distance <= 300 then
                if not Lines[player] then
                    Lines[player] = NewLine()
                end
                
                local localPos = Camera:WorldToViewportPoint(LocalPlayer.Character.HumanoidRootPart.Position)
                local targetPos = Camera:WorldToViewportPoint(player.Character.HumanoidRootPart.Position)
                
                Lines[player].From = Vector2.new(localPos.X, localPos.Y)
                Lines[player].To = Vector2.new(targetPos.X, targetPos.Y)
                Lines[player].Visible = true
            else
                if Lines[player] then
                    Lines[player].Visible = false
                end
            end
        elseif Lines[player] then
            Lines[player].Visible = false
        end
    end
end

-- Cleanup lines for players who leave
Players.PlayerRemoving:Connect(function(player)
    if Lines[player] then
        Lines[player]:Remove()
        Lines[player] = nil
    end
end)

-- Update lines on each frame
RunService.RenderStepped:Connect(UpdateLines)

-- Periodically refresh lines to add any new players
while true do
    wait(10)
    UpdateLines()
end
   end,
})

local Button = VisTab:CreateButton({
   Name = "Charms",
   Callback = function()
        local PlayersService = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local highlightTemplate = Instance.new("Highlight")
        highlightTemplate.Name = "Highlight"
        
        local function applyHighlight(player)
            if player.Character and not player.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Highlight") then
                local highlightClone = highlightTemplate:Clone()
                highlightClone.Adornee = player.Character
                highlightClone.Parent = player.Character:FindFirstChild("HumanoidRootPart")
                highlightClone.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            end
        end
        
        local function refreshHighlights()
            for _, player in ipairs(PlayersService:GetPlayers()) do
                applyHighlight(player)
            end
        end
        
        -- Apply highlights to all current players
        refreshHighlights()
        
        -- Listen for new players and apply highlight
        PlayersService.PlayerAdded:Connect(function(player)
            repeat wait() until player.Character
            applyHighlight(player)
        end)
        
        -- Listen for players leaving and remove highlight
        PlayersService.PlayerRemoving:Connect(function(playerRemoved)
            if playerRemoved.Character and playerRemoved.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Highlight") then
                playerRemoved.Character:FindFirstChild("HumanoidRootPart"):FindFirstChild("Highlight"):Destroy()
            end
        end)
        
        -- Refresh highlights every 5 seconds
        RunService.Heartbeat:Connect(function()
            task.wait(5)
            refreshHighlights()
        end)
        
   end,
})

local Button = VisTab:CreateButton({
   Name = "Name ESP",
   Callback = function()
  
--//Made by Blissful#4992
local settings = {
    Color = Color3.fromRGB(255, 0, 0),
    Size = 15,
    Transparency = 1, -- 1 Visible - 0 Not Visible
    AutoScale = true
}

local space = game:GetService("Workspace")
local player = game:GetService("Players").LocalPlayer
local camera = space.CurrentCamera

local function NewText(color, size, transparency)
    local text = Drawing.new("Text")
    text.Visible = false
    text.Text = ""
    text.Position = Vector2.new(0, 0)
    text.Color = color
    text.Size = size
    text.Center = true
    text.Transparency = transparency
    return text
end

local function Visibility(state, lib)
    for u, x in pairs(lib) do
        x.Visible = state
    end
end

local function Size(size, lib)
    for u, x in pairs(lib) do
        x.Size = size
    end
end

for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    local library = {
        name = NewText(settings.Color, settings.Size, settings.Transparency)
    }
    local function ESP()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v.Name ~= player.Name and v.Character.Humanoid.Health > 0 then
                local HumanoidRootPart_Pos, OnScreen = camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                if OnScreen then
                    library.name.Text = v.Name
                    library.name.Position = Vector2.new(HumanoidRootPart_Pos.X, HumanoidRootPart_Pos.Y)
                    --// AutoScale
                    if settings.AutoScale then
                        local distance = (Vector3.new(camera.CFrame.X, camera.CFrame.Y, camera.CFrame.Z) - v.Character.HumanoidRootPart.Position).magnitude
                        local textsize = math.clamp(1/distance*1000, 2, 30) -- 2 is min text size, 30 is max text size, change to your liking
                        Size(textsize, library)
                    else 
                        Size(settings.Size, library)
                    end
                    --//--
                    Visibility(true, library)
                else 
                    Visibility(false, library)
                end
            else 
                Visibility(false, library)
                if game.Players:FindFirstChild(v.Name) == nil then
                    connection:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(ESP)()
end

game.Players.PlayerAdded:Connect(function(newplr)
    print(newplr)
    local library = {
        name = NewText(settings.Color, settings.Size, settings.Transparency)
    }
    local function ESP()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if newplr.Character ~= nil and newplr.Character:FindFirstChild("Humanoid") ~= nil and newplr.Character:FindFirstChild("HumanoidRootPart") ~= nil and newplr.Name ~= player.Name and newplr.Character.Humanoid.Health > 0 then
                local HumanoidRootPart_Pos, OnScreen = camera:WorldToViewportPoint(newplr.Character.HumanoidRootPart.Position)
                if OnScreen then
                    library.name.Text = newplr.Name
                    library.name.Position = Vector2.new(HumanoidRootPart_Pos.X, HumanoidRootPart_Pos.Y)
                    --// AutoScale
                    if settings.AutoScale then
                        local distance = (Vector3.new(camera.CFrame.X, camera.CFrame.Y, camera.CFrame.Z) - newplr.Character.HumanoidRootPart.Position).magnitude
                        local textsize = math.clamp(1/distance*1000, 2, 30) -- 2 is min text size, 20 is max text size, change to your liking
                        Size(textsize, library)
                    else 
                        Size(settings.Size, library)
                    end
                    --//--
                    Visibility(true, library)
                else 
                    Visibility(false, library)
                end
            else 
                Visibility(false, library)
                if game.Players:FindFirstChild(newplr.Name) == nil then
                    connection:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(ESP)()
end)

   end,
})

local Button = VisTab:CreateButton({
   Name = "Skeleton",
   Callback = function()
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Blissful4992/ESPs/main/UniversalSkeleton.lua"))()

local Skeletons = {}
for _, Player in next, game.Players:GetChildren() do
	table.insert(Skeletons, Library:NewSkeleton(Player, true));
end
game.Players.PlayerAdded:Connect(function(Player)
	table.insert(Skeletons, Library:NewSkeleton(Player, true));
end)
   end,
})

local Button = VisTab:CreateButton({
   Name = "Eye ESP",
   Callback = function()
   
-- Preview: https://gyazo.com/02cfb4aa8659ba5f6ee67a90514cc34d
-- Made by Blissful#4992
local Settings = {
    Color = Color3.fromRGB(255, 203, 138), -- Color of the line
    Thickness = 1, -- Thickness of the line (Overruled by AutoThickness if activated)
    Transparency = 1, -- 1 Visible - 0 Not Visible
    AutoThickness = true, -- Makes Thickness above futile, scales according to distance, good for less encumbered screen
    Length = 15, -- In studs of the line
    Smoothness = 0.2 -- 0.01 - Less Smooth(Faster), 1 - Smoother (Slower)
}

local toggle = true -- use this variable if you wanna integrate into a GUI

local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera

local function ESP(plr) --//Main function handling specific plr loop esp for line etc
    local line = Drawing.new("Line") --// Parse and Set the line for tracer
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = Settings.Color
    line.Thickness = Settings.Thickness
    line.Transparency = Settings.Transparency

    local function Updater() --// Function to update the ESP therefore, line destinations etc every /render/
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function() -- Putting function in a connection var in order to disconnect if needed, to save performance
            if toggle and plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                local headpos, OnScreen = camera:WorldToViewportPoint(plr.Character.Head.Position)
                if OnScreen then -- checks if player is on screen or not
                    local offsetCFrame = CFrame.new(0, 0, -Settings.Length)
                    local check = false
                    line.From = Vector2.new(headpos.X, headpos.Y)
                    if Settings.AutoThickness then
                        local distance = (player.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude --//AutoThickness
                        local value = math.clamp(1/distance*100, 0.1, 3) --0.1 is min thickness, 4 is max
                        line.Thickness = value
                    end
                    repeat
                        local dir = plr.Character.Head.CFrame:ToWorldSpace(offsetCFrame)
                        offsetCFrame = offsetCFrame * CFrame.new(0, 0, Settings.Smoothness)
                        local dirpos, vis = camera:WorldToViewportPoint(Vector3.new(dir.X, dir.Y, dir.Z))
                        if vis then
                            check = true
                            line.To = Vector2.new(dirpos.X, dirpos.Y)
                            line.Visible = true
                            offsetCFrame = CFrame.new(0, 0, -Settings.Length)
                        end
                    until check == true
                else 
                    line.Visible = false
                end
            else 
                line.Visible = false
                if game.Players:FindFirstChild(plr.Name) == nil then
                    connection:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Updater)()
end

for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= player.Name then
        coroutine.wrap(ESP)(v)
    end
end

game.Players.PlayerAdded:Connect(function(newplr)
    if newplr.Name ~= player.Name then
        coroutine.wrap(ESP)(newplr)
    end
end)

   end,
})

local Button = VisTab:CreateButton({
   Name = "Health ESP",
   Callback = function()
local function ApplyESP(v)
   if v.Character and v.Character:FindFirstChildOfClass'Humanoid' then
       v.Character.Humanoid.NameDisplayDistance = 9e9
       v.Character.Humanoid.NameOcclusion = "NoOcclusion"
       v.Character.Humanoid.HealthDisplayDistance = 9e9
       v.Character.Humanoid.HealthDisplayType = "AlwaysOn"
       v.Character.Humanoid.Health = v.Character.Humanoid.Health -- triggers changed
   end
end
for i,v in pairs(game.Players:GetPlayers()) do
   ApplyESP(v)
   v.CharacterAdded:Connect(function()
       task.wait(0.33)
       ApplyESP(v)
   end)
end

game.Players.PlayerAdded:Connect(function(v)
   ApplyESP(v)
   v.CharacterAdded:Connect(function()
       task.wait(0.33)
       ApplyESP(v)
   end)
end)
   end,
})

local Button = VisTab:CreateButton({
Name = "Radar",
   Callback = function()
local Players = game:service("Players")
local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()
local Camera = game:service("Workspace").CurrentCamera
local RS = game:service("RunService")
local UIS = game:service("UserInputService")

repeat wait() until Player.Character ~= nil and Player.Character.PrimaryPart ~= nil

local LerpColorModule = loadstring(game:HttpGet("https://pastebin.com/raw/wRnsJeid"))()
local HealthBarLerp = LerpColorModule:Lerp(Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0))

local function NewCircle(Transparency, Color, Radius, Filled, Thickness)
    local c = Drawing.new("Circle")
    c.Transparency = Transparency
    c.Color = Color
    c.Visible = false
    c.Thickness = Thickness
    c.Position = Vector2.new(0, 0)
    c.Radius = Radius
    c.NumSides = math.clamp(Radius*55/100, 10, 75)
    c.Filled = Filled
    return c
end

local RadarInfo = {
    Position = Vector2.new(200, 200),
    Radius = 100,
    Scale = 1, -- Determinant factor on the effect of the relative position for the 2D integration
    RadarBack = Color3.fromRGB(10, 10, 10),
    RadarBorder = Color3.fromRGB(75, 75, 75),
    LocalPlayerDot = Color3.fromRGB(255, 255, 255),
    PlayerDot = Color3.fromRGB(60, 170, 255),
    Team = Color3.fromRGB(0, 255, 0),
    Enemy = Color3.fromRGB(255, 0, 0),
    Health_Color = true,
    Team_Check = true
}

local RadarBackground = NewCircle(0.9, RadarInfo.RadarBack, RadarInfo.Radius, true, 1)
RadarBackground.Visible = true
RadarBackground.Position = RadarInfo.Position

local RadarBorder = NewCircle(0.75, RadarInfo.RadarBorder, RadarInfo.Radius, false, 3)
RadarBorder.Visible = true
RadarBorder.Position = RadarInfo.Position

local function GetRelative(pos)
    local char = Player.Character
    if char ~= nil and char.PrimaryPart ~= nil then
        local pmpart = char.PrimaryPart
        local camerapos = Vector3.new(Camera.CFrame.Position.X, pmpart.Position.Y, Camera.CFrame.Position.Z)
        local newcf = CFrame.new(pmpart.Position, camerapos)
        local r = newcf:PointToObjectSpace(pos)
        return r.X, r.Z
    else
        return 0, 0
    end
end

local function PlaceDot(plr)
    local PlayerDot = NewCircle(1, RadarInfo.PlayerDot, 3, true, 1)

    local function Update()
        local c 
        c = game:service("RunService").RenderStepped:Connect(function()
            local char = plr.Character
            if char and char:FindFirstChildOfClass("Humanoid") and char.PrimaryPart ~= nil and char:FindFirstChildOfClass("Humanoid").Health > 0 then
                local hum = char:FindFirstChildOfClass("Humanoid")
                local scale = RadarInfo.Scale
                local relx, rely = GetRelative(char.PrimaryPart.Position)
                local newpos = RadarInfo.Position - Vector2.new(relx * scale, rely * scale) 
                
                if (newpos - RadarInfo.Position).magnitude < RadarInfo.Radius-2 then 
                    PlayerDot.Radius = 3   
                    PlayerDot.Position = newpos
                    PlayerDot.Visible = true
                else 
                    local dist = (RadarInfo.Position - newpos).magnitude
                    local calc = (RadarInfo.Position - newpos).unit * (dist - RadarInfo.Radius)
                    local inside = Vector2.new(newpos.X + calc.X, newpos.Y + calc.Y)
                    PlayerDot.Radius = 2
                    PlayerDot.Position = inside
                    PlayerDot.Visible = true
                end

                PlayerDot.Color = RadarInfo.PlayerDot
                if RadarInfo.Team_Check then
                    if plr.TeamColor == Player.TeamColor then
                        PlayerDot.Color = RadarInfo.Team
                    else
                        PlayerDot.Color = RadarInfo.Enemy
                    end
                end

                if RadarInfo.Health_Color then
                    PlayerDot.Color = HealthBarLerp(hum.Health / hum.MaxHealth)
                end
            else 
                PlayerDot.Visible = false
                if Players:FindFirstChild(plr.Name) == nil then
                    PlayerDot:Remove()
                    c:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Update)()
end

for _,v in pairs(Players:GetChildren()) do
    if v.Name ~= Player.Name then
        PlaceDot(v)
    end
end

local function NewLocalDot()
    local d = Drawing.new("Triangle")
    d.Visible = true
    d.Thickness = 1
    d.Filled = true
    d.Color = RadarInfo.LocalPlayerDot
    d.PointA = RadarInfo.Position + Vector2.new(0, -6)
    d.PointB = RadarInfo.Position + Vector2.new(-3, 6)
    d.PointC = RadarInfo.Position + Vector2.new(3, 6)
    return d
end

local LocalPlayerDot = NewLocalDot()

Players.PlayerAdded:Connect(function(v)
    if v.Name ~= Player.Name then
        PlaceDot(v)
    end
    LocalPlayerDot:Remove()
    LocalPlayerDot = NewLocalDot()
end)

-- Loop
coroutine.wrap(function()
    local c 
    c = game:service("RunService").RenderStepped:Connect(function()
        if LocalPlayerDot ~= nil then
            LocalPlayerDot.Color = RadarInfo.LocalPlayerDot
            LocalPlayerDot.PointA = RadarInfo.Position + Vector2.new(0, -6)
            LocalPlayerDot.PointB = RadarInfo.Position + Vector2.new(-3, 6)
            LocalPlayerDot.PointC = RadarInfo.Position + Vector2.new(3, 6)
        end
        RadarBackground.Position = RadarInfo.Position
        RadarBackground.Radius = RadarInfo.Radius
        RadarBackground.Color = RadarInfo.RadarBack

        RadarBorder.Position = RadarInfo.Position
        RadarBorder.Radius = RadarInfo.Radius
        RadarBorder.Color = RadarInfo.RadarBorder
    end)
end)()

-- Draggable
local inset = game:service("GuiService"):GetGuiInset()

local dragging = false
local offset = Vector2.new(0, 0)
UIS.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and (Vector2.new(Mouse.X, Mouse.Y + inset.Y) - RadarInfo.Position).magnitude < RadarInfo.Radius then
        offset = RadarInfo.Position - Vector2.new(Mouse.X, Mouse.Y)
        dragging = true
    end
end)

UIS.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

coroutine.wrap(function()
    local dot = NewCircle(1, Color3.fromRGB(255, 255, 255), 3, true, 1)
    local c 
    c = game:service("RunService").RenderStepped:Connect(function()
        if (Vector2.new(Mouse.X, Mouse.Y + inset.Y) - RadarInfo.Position).magnitude < RadarInfo.Radius then
            dot.Position = Vector2.new(Mouse.X, Mouse.Y + inset.Y)
            dot.Visible = true
        else 
            dot.Visible = false
        end
        if dragging then
            RadarInfo.Position = Vector2.new(Mouse.X, Mouse.Y) + offset
        end
    end)
end)()

--[[ Example:
wait(3)
RadarInfo.Position = Vector2.new(300, 300)
RadarInfo.Radius = 150
RadarInfo.RadarBack = Color3.fromRGB(50, 0, 0)
]]
   end,
})

local VisSection = VisTab:CreateSection("World")

local Button = VisTab:CreateButton({
   Name = "Night/daytime",
   Callback = function()
   loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Night%20Time%20Toggle.txt"))()
   end,
})

local CharacterTab = Window:CreateTab("Character", nil) -- Title, Image
local CharacterSection = CharacterTab:CreateSection("Tweaks")

local Button = CharacterTab:CreateButton({
   Name = "Infinite Jump Toggle",
   Callback = function()
       --Toggles the infinite jump between on or off on every script run
_G.infinjump = not _G.infinjump

if _G.infinJumpStarted == nil then
	--Ensures this only runs once to save resources
	_G.infinJumpStarted = true
	
	--Notifies readiness
	game.StarterGui:SetCore("SendNotification", {Title="Youtube Hub"; Text="Infinite Jump Activated!"; Duration=5;})

	--The actual infinite jump
	local plr = game:GetService('Players').LocalPlayer
	local m = plr:GetMouse()
	m.KeyDown:connect(function(k)
		if _G.infinjump then
			if k:byte() == 32 then
			humanoid = game:GetService'Players'.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
			humanoid:ChangeState('Jumping')
			wait()
			humanoid:ChangeState('Seated')
			end
		end
	end)
end
   end,
})

local Slider = CharacterTab:CreateSlider({
   Name = "WalkSpeed Slider",
   Range = {1, 500},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "sliderws", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
   end,
})

local Slider = CharacterTab:CreateSlider({
   Name = "JumpPower Slider",
   Range = {1, 500},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "sliderjp", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = (Value)
   end,
})

local Button = CharacterTab:CreateButton({
   Name = "Flight",
   Callback = function()
loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Fly.txt"))()   
   end,
})

local Button = CharacterTab:CreateButton({
   Name = "Noclip (N)",
   Callback = function()
   getgenv().Players = game:GetService'Players'
getgenv().Host = Players.LocalPlayer
getgenv().AddNotification = function(title, text) game:GetService'StarterGui':SetCore("SendNotification", {Title = title; Text = text;}) end
getgenv().RunService = game:GetService'RunService';
getgenv().ContextActionService = game:GetService'ContextActionService';

local Noclip = true;
local NoclipKey = 'N'; -- Change your key here

RunService.RenderStepped:Connect(function()
    if Noclip then
        for _,v in pairs(Host.Character:GetDescendants()) do
            if v:IsA'BasePart' and v.CanCollide then
                v.CanCollide = false
            end
        end
    else
        for _,v in pairs(Host.Character:GetDescendants()) do
            if v:IsA'BasePart' and not v.CanCollide then
                v.CanCollide = true
            end
        end
    end
end)

function Noclipping(ActionName:string, Properties:EnumItem)
    if ActionName == 'Noclip' then
        if not Properties or Properties == Enum.UserInputState.Begin then
            Noclip = not Noclip
            AddNotification('Noclip','Noclip is now - '..tostring(Noclip))
        end
    end
end

ContextActionService:BindAction('Noclip', Noclipping, true, Enum.KeyCode[NoclipKey])
   end,
})

local CharacterSection = CharacterTab:CreateSection("Other")

local Button = CharacterTab:CreateButton({
   Name = "Human Flashlight",
   Callback = function()
loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Human%20Flashlight.txt"))()  
    end,
})

local Button = CharacterTab:CreateButton({
   Name = "Remove Legs",
   Callback = function()
   loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Remove%20Legs.txt"))()
   end,
})

local Button = CharacterTab:CreateButton({
   Name = "High Hips",
   Callback = function()
   loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/High%20Hips.txt"))()
   end,
})

local Button = CharacterTab:CreateButton({
   Name = "Float",
   Callback = function()
   loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Float%20Character.txt"))()
   end,
})

local Button = CharacterTab:CreateButton({
   Name = "Ctrl + Click tp",
   Callback = function()
   loadstring(game:HttpGet("https://cdn.wearedevs.net/scripts/Click%20Teleport.txt"))()
   end,
})

local AimTab = Window:CreateTab("Aim", nil) -- Title, Image
local AimSection = AimTab:CreateSection("Aimbot,CameraLock m.m")

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local Camera = workspace.CurrentCamera

-- Variables
local teamCheck = false
local fov = 90
local smoothing = 0.85
local predictionFactor = 0.02
local highlightEnabled = true -- Enable or disable target highlighting
local lockPart = "Head" -- Lock onto this part (e.g., HumanoidRootPart or Head)

local aimlockActivated = false -- Controlled by pressing X
local toggleState = false -- Controlled by UI toggle (OFF by default)
local aimbotEnabled = false -- Fully turns ON when toggle + activation key (X) are both used

-- Drawing FOV Circle
local FOVring = Drawing.new("Circle")
FOVring.Visible = false -- Initially invisible
FOVring.Thickness = 1
FOVring.Radius = fov
FOVring.Transparency = 0.5
FOVring.Color = Color3.fromRGB(132, 182, 141)

-- Helper Functions
local function updateFOVRing()
    if toggleState then
        local screenCenter = Camera.ViewportSize / 2
        FOVring.Position = screenCenter
        FOVring.Visible = true
    else
        FOVring.Visible = false
    end
end

local function highlightTarget(target)
    if highlightEnabled and target and target.Character then
        local highlight = Instance.new("Highlight")
        highlight.Adornee = target.Character
        highlight.FillColor = Color3.fromRGB(255, 128, 128)
        highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
        highlight.Parent = target.Character
    end
end

local function removeHighlight(target)
    if target and target.Character and target.Character:FindFirstChildOfClass("Highlight") then
        target.Character:FindFirstChildOfClass("Highlight"):Destroy()
    end
end

local function predictPosition(target)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local velocity = target.Character.HumanoidRootPart.Velocity
        local position = target.Character[lockPart].Position
        return position + (velocity * predictionFactor)
    end
    return nil
end

local function getClosestTarget()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local screenCenter = Camera.ViewportSize / 2

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild(lockPart) and player.Character:FindFirstChild("Humanoid") then
            if not teamCheck or player.Team ~= Players.LocalPlayer.Team then
                local screenPosition, onScreen = Camera:WorldToViewportPoint(player.Character[lockPart].Position)
                local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - screenCenter).Magnitude

                if onScreen and distance <= fov and distance < shortestDistance then
                    closestPlayer = player
                    shortestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

-- Toggle Integration for UI
local Toggle = AimTab:CreateToggle({
    Name = "Enable Aimlock",
    CurrentValue = toggleState, -- Starts OFF
    Flag = "Toggle2",
    Callback = function(Value)
        toggleState = Value
        aimlockActivated = false -- Reset activation state when toggled
        StarterGui:SetCore("SendNotification", {
            Title = "Aimlock Status";
            Text = toggleState and "Enabled" or "Disabled";
            Duration = 2;
        })
    end,
})

-- Listen for Activation Key (X)
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.X and toggleState then
        aimlockActivated = not aimlockActivated -- Toggle aimlock activation
        StarterGui:SetCore("SendNotification", {
            Title = "Aimlock Activation";
            Text = aimlockActivated and "Activated" or "Deactivated";
            Duration = 2;
        })
    end
end)

-- Main Logic Loop
RunService.RenderStepped:Connect(function()
    updateFOVRing() -- Update FOV ring visibility and position

    if toggleState and aimlockActivated then
        local target = getClosestTarget()

        if target then
            if target.Character and target.Character:FindFirstChild(lockPart) then
                highlightTarget(target) -- Highlight target
                local predictedPosition = predictPosition(target)
                if predictedPosition then
                    Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedPosition), smoothing)
                end
                FOVring.Color = Color3.fromRGB(0, 255, 0) -- Green when locked onto target
            end
        else
            FOVring.Color = Color3.fromRGB(255, 128, 128) -- Revert to original color if no target
        end
    else
        if FOVring.Visible then
            FOVring.Color = Color3.fromRGB(255, 128, 128) -- Original color
        end
    end
end)

print("Aimlock Script with Toggle and Activation Key Loaded Successfully!")


-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- Variables
local silentAimActive = false -- Controlled by the toggle
local fovRadius = 200 -- Initial FOV radius in pixels
local fovCircleVisible = true -- Toggle FOV circle visibility

-- FOV Circle Drawing
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = fovCircleVisible
fovCircle.Transparency = 1
fovCircle.Thickness = 2
fovCircle.Color = Color3.fromRGB(0, 255, 0) -- Green color for FOV
fovCircle.Radius = fovRadius
fovCircle.Filled = false

-- Function to update the FOV Circle's position
local function updateFOVCircle()
    local mousePosition = UserInputService:GetMouseLocation()
    fovCircle.Position = mousePosition
    fovCircle.Visible = silentAimActive -- Show the FOV circle only if aimlock is enabled
end

-- Function to get the nearest target's head within FOV
local function getNearestHeadInFOV()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local head = player.Character:FindFirstChild("Head")
            local screenPosition, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

            -- Check if the target is within the FOV radius
            if onScreen then
                local mousePosition = UserInputService:GetMouseLocation()
                local distanceFromMouse = (Vector2.new(screenPosition.X, screenPosition.Y) - mousePosition).Magnitude
                if distanceFromMouse <= fovRadius and distanceFromMouse < shortestDistance then
                    shortestDistance = distanceFromMouse
                    closestPlayer = player
                end
            end
        end
    end

    if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("Head") then
        return closestPlayer.Character.Head
    end

    return nil
end

-- Silent aim functionality with headshots
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and silentAimActive then
        local targetHead = getNearestHeadInFOV()
        if targetHead then
            local aimPosition = targetHead.Position
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, aimPosition)
            ReplicatedStorage.Remotes.Attack:FireServer(targetHead)
        end
    end
end)

-- Toggle to enable/disable aimlock
local Toggle = AimTab:CreateToggle({
    Name = "Enable Aimlock",
    CurrentValue = silentAimActive,
    Flag = "AimlockToggle",
    Callback = function(Value)
        silentAimActive = Value -- Set aimlock state based on toggle
    end,
})

-- Slider to control FOV radius
local Slider = AimTab:CreateSlider({
    Name = "Aimlock FOV",
    Range = {50, 500}, -- Minimum and maximum radius
    Increment = 1,
    Suffix = " FOV", -- Display as "Pixels"
    CurrentValue = fovRadius,
    Flag = "FOVSlider",
    Callback = function(Value)
        fovRadius = Value -- Update FOV radius
        fovCircle.Radius = fovRadius -- Update the visual representation
    end,
})

-- Update the FOV Circle every frame
RunService.RenderStepped:Connect(function()
    updateFOVCircle()
end)

print("Aimlock System with Dropdown, Toggle, and Slider loaded successfully.")
